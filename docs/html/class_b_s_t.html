<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>A Binary Search Tree Implementation: BST&lt; KeyType, ValueType, KeyTypeLess &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">A Binary Search Tree Implementation
   &#160;<span id="projectnumber">0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_b_s_t-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">BST&lt; KeyType, ValueType, KeyTypeLess &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class implements a generic Binary Search Tree.  
 <a href="class_b_s_t.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="bst_8h_source.html">bst.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_s_t_1_1_b_t_node.html">BTNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a single binary search tree node.  <a href="struct_b_s_t_1_1_b_t_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0aa9307cbee74945dbbbf659c398d4a1"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; KeyType, ValueType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#a0aa9307cbee74945dbbbf659c398d4a1">node_content_type</a></td></tr>
<tr class="memdesc:a0aa9307cbee74945dbbbf659c398d4a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a pair of key-value elements.  <a href="#a0aa9307cbee74945dbbbf659c398d4a1">More...</a><br /></td></tr>
<tr class="separator:a0aa9307cbee74945dbbbf659c398d4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a092e33c1b889b35fb95afda49ca1191c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#a092e33c1b889b35fb95afda49ca1191c">BST</a> (const KeyTypeLess &amp;comp=KeyTypeLess())</td></tr>
<tr class="memdesc:a092e33c1b889b35fb95afda49ca1191c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a092e33c1b889b35fb95afda49ca1191c">More...</a><br /></td></tr>
<tr class="separator:a092e33c1b889b35fb95afda49ca1191c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3d9ab6deb17f9dc3fa19d01a46f8e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#a9c3d9ab6deb17f9dc3fa19d01a46f8e3">BST</a> (const <a class="el" href="class_b_s_t.html">BST</a> &amp;other)</td></tr>
<tr class="memdesc:a9c3d9ab6deb17f9dc3fa19d01a46f8e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a9c3d9ab6deb17f9dc3fa19d01a46f8e3">More...</a><br /></td></tr>
<tr class="separator:a9c3d9ab6deb17f9dc3fa19d01a46f8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b5f3bb6438a7cdba827dc77d1d4ce5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#a99b5f3bb6438a7cdba827dc77d1d4ce5">~BST</a> ()</td></tr>
<tr class="memdesc:a99b5f3bb6438a7cdba827dc77d1d4ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Regular destructor.  <a href="#a99b5f3bb6438a7cdba827dc77d1d4ce5">More...</a><br /></td></tr>
<tr class="separator:a99b5f3bb6438a7cdba827dc77d1d4ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8811bb87594111984e2ae68a88586af2"><td class="memTemplParams" colspan="2">template&lt;typename InputItr &gt; </td></tr>
<tr class="memitem:a8811bb87594111984e2ae68a88586af2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#a8811bb87594111984e2ae68a88586af2">BST</a> (InputItr first, InputItr last, const KeyTypeLess &amp;comp=KeyTypeLess())</td></tr>
<tr class="memdesc:a8811bb87594111984e2ae68a88586af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The range constructor.  <a href="#a8811bb87594111984e2ae68a88586af2">More...</a><br /></td></tr>
<tr class="separator:a8811bb87594111984e2ae68a88586af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07b4e6d6818494bbc892df89ee4daad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#ab07b4e6d6818494bbc892df89ee4daad">BST</a> (std::initializer_list&lt; <a class="el" href="class_b_s_t.html#a0aa9307cbee74945dbbbf659c398d4a1">node_content_type</a> &gt; init, const KeyTypeLess &amp;comp=KeyTypeLess())</td></tr>
<tr class="memdesc:ab07b4e6d6818494bbc892df89ee4daad"><td class="mdescLeft">&#160;</td><td class="mdescRight">The intializer list constructor.  <a href="#ab07b4e6d6818494bbc892df89ee4daad">More...</a><br /></td></tr>
<tr class="separator:ab07b4e6d6818494bbc892df89ee4daad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777c36ccd3b24f144e0603f20f5eac9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_b_s_t.html">BST</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#a777c36ccd3b24f144e0603f20f5eac9d">operator=</a> (const <a class="el" href="class_b_s_t.html">BST</a> &amp;rhs)</td></tr>
<tr class="memdesc:a777c36ccd3b24f144e0603f20f5eac9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The copy assignment operator.  <a href="#a777c36ccd3b24f144e0603f20f5eac9d">More...</a><br /></td></tr>
<tr class="separator:a777c36ccd3b24f144e0603f20f5eac9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcafcb893066444795e8145684011457"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_b_s_t.html">BST</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#abcafcb893066444795e8145684011457">operator=</a> (std::initializer_list&lt; <a class="el" href="class_b_s_t.html#a0aa9307cbee74945dbbbf659c398d4a1">node_content_type</a> &gt; ilist)</td></tr>
<tr class="memdesc:abcafcb893066444795e8145684011457"><td class="mdescLeft">&#160;</td><td class="mdescRight">The initializer list assignment operator.  <a href="#abcafcb893066444795e8145684011457">More...</a><br /></td></tr>
<tr class="separator:abcafcb893066444795e8145684011457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a262042430a5671f2964ec55fd0db5887"><td class="memItemLeft" align="right" valign="top">const ValueType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#a262042430a5671f2964ec55fd0db5887">find_min</a> (void) const </td></tr>
<tr class="memdesc:a262042430a5671f2964ec55fd0db5887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value associated with the smallest key.  <a href="#a262042430a5671f2964ec55fd0db5887">More...</a><br /></td></tr>
<tr class="separator:a262042430a5671f2964ec55fd0db5887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1610824df7207dd077fec30b82174a9e"><td class="memItemLeft" align="right" valign="top">const ValueType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#a1610824df7207dd077fec30b82174a9e">find_max</a> (void) const </td></tr>
<tr class="memdesc:a1610824df7207dd077fec30b82174a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value associated with the largest key.  <a href="#a1610824df7207dd077fec30b82174a9e">More...</a><br /></td></tr>
<tr class="separator:a1610824df7207dd077fec30b82174a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959aa07758e3ff26890e37db2a31b6b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#a959aa07758e3ff26890e37db2a31b6b2">contains</a> (const KeyType &amp;key) const </td></tr>
<tr class="memdesc:a959aa07758e3ff26890e37db2a31b6b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> contains a given key.  <a href="#a959aa07758e3ff26890e37db2a31b6b2">More...</a><br /></td></tr>
<tr class="separator:a959aa07758e3ff26890e37db2a31b6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582ec5f3bc333f1e9c1deed3526e6a55"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#a582ec5f3bc333f1e9c1deed3526e6a55">empty</a> (void) const </td></tr>
<tr class="memdesc:a582ec5f3bc333f1e9c1deed3526e6a55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> is empty, or false otherwise.  <a href="#a582ec5f3bc333f1e9c1deed3526e6a55">More...</a><br /></td></tr>
<tr class="separator:a582ec5f3bc333f1e9c1deed3526e6a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95dafd989628a5cf95f8e82151bbb432"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#a95dafd989628a5cf95f8e82151bbb432">size</a> (void) const </td></tr>
<tr class="memdesc:a95dafd989628a5cf95f8e82151bbb432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of key-value elements stored in the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a>.  <a href="#a95dafd989628a5cf95f8e82151bbb432">More...</a><br /></td></tr>
<tr class="separator:a95dafd989628a5cf95f8e82151bbb432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad969e54369b6edee09f68b2b79a22f08"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#ad969e54369b6edee09f68b2b79a22f08">retrieve</a> (const KeyType &amp;key, ValueType &amp;value) const </td></tr>
<tr class="memdesc:ad969e54369b6edee09f68b2b79a22f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves in <code>value</code> the value associated with the provided key.  <a href="#ad969e54369b6edee09f68b2b79a22f08">More...</a><br /></td></tr>
<tr class="separator:ad969e54369b6edee09f68b2b79a22f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afafd8425898de634afe1d229420cfbb8"><td class="memTemplParams" colspan="2">template&lt;typename UnaryFunction &gt; </td></tr>
<tr class="memitem:afafd8425898de634afe1d229420cfbb8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#afafd8425898de634afe1d229420cfbb8">preorder</a> (const UnaryFunction &amp;visit) const </td></tr>
<tr class="memdesc:afafd8425898de634afe1d229420cfbb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverses and visits each <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> node in <b>preorder</b> fashion.  <a href="#afafd8425898de634afe1d229420cfbb8">More...</a><br /></td></tr>
<tr class="separator:afafd8425898de634afe1d229420cfbb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938be48246fd9b0b81e64d111f2e1a5d"><td class="memTemplParams" colspan="2">template&lt;typename UnaryFunction &gt; </td></tr>
<tr class="memitem:a938be48246fd9b0b81e64d111f2e1a5d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#a938be48246fd9b0b81e64d111f2e1a5d">postorder</a> (const UnaryFunction &amp;visit) const </td></tr>
<tr class="memdesc:a938be48246fd9b0b81e64d111f2e1a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverses and visits each <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> node in <b>postorder</b> fashion.  <a href="#a938be48246fd9b0b81e64d111f2e1a5d">More...</a><br /></td></tr>
<tr class="separator:a938be48246fd9b0b81e64d111f2e1a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46608ca07862f7f13cf3520ec6ade82d"><td class="memTemplParams" colspan="2">template&lt;typename UnaryFunction &gt; </td></tr>
<tr class="memitem:a46608ca07862f7f13cf3520ec6ade82d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#a46608ca07862f7f13cf3520ec6ade82d">inorder</a> (const UnaryFunction &amp;visit) const </td></tr>
<tr class="memdesc:a46608ca07862f7f13cf3520ec6ade82d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverses and visits each <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> node in <b>inorder</b> fashion.  <a href="#a46608ca07862f7f13cf3520ec6ade82d">More...</a><br /></td></tr>
<tr class="separator:a46608ca07862f7f13cf3520ec6ade82d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ffadf800779b0f1b1a9742a3bc5cf66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#a6ffadf800779b0f1b1a9742a3bc5cf66">clear</a> (void)</td></tr>
<tr class="memdesc:a6ffadf800779b0f1b1a9742a3bc5cf66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all the elements from the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a>.  <a href="#a6ffadf800779b0f1b1a9742a3bc5cf66">More...</a><br /></td></tr>
<tr class="separator:a6ffadf800779b0f1b1a9742a3bc5cf66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a809a130ceaa2dbb3a2b077f321675593"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#a809a130ceaa2dbb3a2b077f321675593">insert</a> (const KeyType &amp;key, const ValueType &amp;value)</td></tr>
<tr class="memdesc:a809a130ceaa2dbb3a2b077f321675593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new pair &lt;<code>key</code>,<code>value</code>&gt; in the tree.  <a href="#a809a130ceaa2dbb3a2b077f321675593">More...</a><br /></td></tr>
<tr class="separator:a809a130ceaa2dbb3a2b077f321675593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f0f207322311366b9b014755a798ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#aa9f0f207322311366b9b014755a798ab">remove</a> (const KeyType &amp;)</td></tr>
<tr class="memdesc:aa9f0f207322311366b9b014755a798ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes from the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> a node containing the requested key.  <a href="#aa9f0f207322311366b9b014755a798ab">More...</a><br /></td></tr>
<tr class="separator:aa9f0f207322311366b9b014755a798ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a2caab48e5c6f1400f7b9ae2e11fb1680"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#a2caab48e5c6f1400f7b9ae2e11fb1680">insert</a> (<a class="el" href="struct_b_s_t_1_1_b_t_node.html">BTNode</a> *&amp;root, const KeyType &amp;key, const ValueType &amp;value)</td></tr>
<tr class="memdesc:a2caab48e5c6f1400f7b9ae2e11fb1680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new pair &lt;<code>key</code>,<code>value</code>&gt; in the tree.  <a href="#a2caab48e5c6f1400f7b9ae2e11fb1680">More...</a><br /></td></tr>
<tr class="separator:a2caab48e5c6f1400f7b9ae2e11fb1680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3369784d746d15731edf741729f15ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#ab3369784d746d15731edf741729f15ad">remove</a> (<a class="el" href="struct_b_s_t_1_1_b_t_node.html">BTNode</a> *&amp;root, const KeyType &amp;key)</td></tr>
<tr class="memdesc:ab3369784d746d15731edf741729f15ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes from the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> a node containing the requested key.  <a href="#ab3369784d746d15731edf741729f15ad">More...</a><br /></td></tr>
<tr class="separator:ab3369784d746d15731edf741729f15ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c014718dd218e2ca758af266cc0b787"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#a3c014718dd218e2ca758af266cc0b787">contains</a> (const <a class="el" href="struct_b_s_t_1_1_b_t_node.html">BTNode</a> *root, const KeyType &amp;key) const </td></tr>
<tr class="memdesc:a3c014718dd218e2ca758af266cc0b787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> contains a given key.  <a href="#a3c014718dd218e2ca758af266cc0b787">More...</a><br /></td></tr>
<tr class="separator:a3c014718dd218e2ca758af266cc0b787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e63b5360a5252606dece4c5972c36d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#ad4e63b5360a5252606dece4c5972c36d">retrieve</a> (const <a class="el" href="struct_b_s_t_1_1_b_t_node.html">BTNode</a> *root, const KeyType &amp;key, ValueType &amp;value) const </td></tr>
<tr class="memdesc:ad4e63b5360a5252606dece4c5972c36d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves in <code>value</code> the value associated with the provided key.  <a href="#ad4e63b5360a5252606dece4c5972c36d">More...</a><br /></td></tr>
<tr class="separator:ad4e63b5360a5252606dece4c5972c36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ef77647f785480d292d2315550f734"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#a55ef77647f785480d292d2315550f734">clear</a> (<a class="el" href="struct_b_s_t_1_1_b_t_node.html">BTNode</a> *&amp;root)</td></tr>
<tr class="memdesc:a55ef77647f785480d292d2315550f734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all the elements from the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a>.  <a href="#a55ef77647f785480d292d2315550f734">More...</a><br /></td></tr>
<tr class="separator:a55ef77647f785480d292d2315550f734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21ef870def521a698f5ad9672badd1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_b_s_t_1_1_b_t_node.html">BTNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#af21ef870def521a698f5ad9672badd1f">clone</a> (const <a class="el" href="struct_b_s_t_1_1_b_t_node.html">BTNode</a> *root)</td></tr>
<tr class="memdesc:af21ef870def521a698f5ad9672badd1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a copy of a <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> tree.  <a href="#af21ef870def521a698f5ad9672badd1f">More...</a><br /></td></tr>
<tr class="separator:af21ef870def521a698f5ad9672badd1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b4da6797656b7155f92fa7e2be3f1d"><td class="memTemplParams" colspan="2">template&lt;typename UnaryFunction &gt; </td></tr>
<tr class="memitem:a10b4da6797656b7155f92fa7e2be3f1d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#a10b4da6797656b7155f92fa7e2be3f1d">preorder</a> (const <a class="el" href="struct_b_s_t_1_1_b_t_node.html">BTNode</a> *root, const UnaryFunction &amp;visit) const </td></tr>
<tr class="memdesc:a10b4da6797656b7155f92fa7e2be3f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverses and visits each <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> node in <b>preorder</b> fashion.  <a href="#a10b4da6797656b7155f92fa7e2be3f1d">More...</a><br /></td></tr>
<tr class="separator:a10b4da6797656b7155f92fa7e2be3f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b5bd16742a542b361eebe5f2baa310"><td class="memTemplParams" colspan="2">template&lt;typename UnaryFunction &gt; </td></tr>
<tr class="memitem:a11b5bd16742a542b361eebe5f2baa310"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#a11b5bd16742a542b361eebe5f2baa310">postorder</a> (const <a class="el" href="struct_b_s_t_1_1_b_t_node.html">BTNode</a> *root, const UnaryFunction &amp;visit) const </td></tr>
<tr class="memdesc:a11b5bd16742a542b361eebe5f2baa310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverses and visits each <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> node in <b>postorder</b> fashion.  <a href="#a11b5bd16742a542b361eebe5f2baa310">More...</a><br /></td></tr>
<tr class="separator:a11b5bd16742a542b361eebe5f2baa310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbfbc935cb31754a1715cca4490994f8"><td class="memTemplParams" colspan="2">template&lt;typename UnaryFunction &gt; </td></tr>
<tr class="memitem:abbfbc935cb31754a1715cca4490994f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#abbfbc935cb31754a1715cca4490994f8">inorder</a> (const <a class="el" href="struct_b_s_t_1_1_b_t_node.html">BTNode</a> *root, const UnaryFunction &amp;visit) const </td></tr>
<tr class="memdesc:abbfbc935cb31754a1715cca4490994f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverses and visits each <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> node in <b>inorder</b> fashion.  <a href="#abbfbc935cb31754a1715cca4490994f8">More...</a><br /></td></tr>
<tr class="separator:abbfbc935cb31754a1715cca4490994f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da99953436debe2868f93bd18398b11"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_b_s_t_1_1_b_t_node.html">BTNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#a2da99953436debe2868f93bd18398b11">get_smallest_leaf</a> (const <a class="el" href="struct_b_s_t_1_1_b_t_node.html">BTNode</a> *root) const </td></tr>
<tr class="memdesc:a2da99953436debe2868f93bd18398b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> node with the smallest key value.  <a href="#a2da99953436debe2868f93bd18398b11">More...</a><br /></td></tr>
<tr class="separator:a2da99953436debe2868f93bd18398b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:af2a361060692deacc5be429288eece96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_b_s_t_1_1_b_t_node.html">BTNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#af2a361060692deacc5be429288eece96">m_root</a></td></tr>
<tr class="memdesc:af2a361060692deacc5be429288eece96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the root of the entire tree.  <a href="#af2a361060692deacc5be429288eece96">More...</a><br /></td></tr>
<tr class="separator:af2a361060692deacc5be429288eece96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f358a38c855ebc8bd866f6ae96aa5a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#a38f358a38c855ebc8bd866f6ae96aa5a">m_n_nodes</a></td></tr>
<tr class="memdesc:a38f358a38c855ebc8bd866f6ae96aa5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The count of nodes stored in the tree.  <a href="#a38f358a38c855ebc8bd866f6ae96aa5a">More...</a><br /></td></tr>
<tr class="separator:a38f358a38c855ebc8bd866f6ae96aa5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6d8e3ed3109602f468ef20d03f733c"><td class="memItemLeft" align="right" valign="top">KeyTypeLess&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#a7a6d8e3ed3109602f468ef20d03f733c">m_key_less</a></td></tr>
<tr class="memdesc:a7a6d8e3ed3109602f468ef20d03f733c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The key comparator function object.  <a href="#a7a6d8e3ed3109602f468ef20d03f733c">More...</a><br /></td></tr>
<tr class="separator:a7a6d8e3ed3109602f468ef20d03f733c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aaf95a8d45e30cd664017a788b0c5193b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#aaf95a8d45e30cd664017a788b0c5193b">operator&lt;&lt;</a> (std::ostream &amp;os_, const <a class="el" href="class_b_s_t.html">BST</a> &amp;root_)</td></tr>
<tr class="memdesc:aaf95a8d45e30cd664017a788b0c5193b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints out an ascii tree-bar representation of the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a>.  <a href="#aaf95a8d45e30cd664017a788b0c5193b">More...</a><br /></td></tr>
<tr class="separator:aaf95a8d45e30cd664017a788b0c5193b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename KeyType, typename ValueType, typename KeyTypeLess = std::less&lt;KeyType&gt;&gt;<br />
class BST&lt; KeyType, ValueType, KeyTypeLess &gt;</h3>

<p>This class implements a generic Binary Search Tree. </p>
<p><a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> is a sorted associative container that stores key-value pairs with unique keys. Keys are sorted by using the comparison function KeyTypeLess. The elements of the container (nodes) are structured as a Binary Search Tree (<a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a>).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>The type of the key associated with the data. </td></tr>
    <tr><td class="paramname">ValueType</td><td>The type of the data to be stored in the tree. </td></tr>
    <tr><td class="paramname">KeyTypeLess</td><td>A function object that compares two keys and returns true if the first argument of the call appears first than the second argument in the strict weak ordering relation induced by the KeyType, and false otherwise.</td></tr>
  </table>
  </dd>
</dl>
<p>By default we try to instantiate a STL's std::less&lt;KeyType&gt; function object if one is available for the KeyType provided. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a0aa9307cbee74945dbbbf659c398d4a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType , typename KeyTypeLess  = std::less&lt;KeyType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;KeyType, ValueType&gt; <a class="el" href="class_b_s_t.html">BST</a>&lt; KeyType, ValueType, KeyTypeLess &gt;::<a class="el" href="class_b_s_t.html#a0aa9307cbee74945dbbbf659c398d4a1">node_content_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents a pair of key-value elements. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a092e33c1b889b35fb95afda49ca1191c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType , typename KeyTypeLess  = std::less&lt;KeyType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_t.html">BST</a>&lt; KeyType, ValueType, KeyTypeLess &gt;::<a class="el" href="class_b_s_t.html">BST</a> </td>
          <td>(</td>
          <td class="paramtype">const KeyTypeLess &amp;&#160;</td>
          <td class="paramname"><em>comp</em> = <code>KeyTypeLess()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Creates an empty <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>The function object necessary to compare keys. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9c3d9ab6deb17f9dc3fa19d01a46f8e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType , typename KeyTypeLess  = std::less&lt;KeyType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_t.html">BST</a>&lt; KeyType, ValueType, KeyTypeLess &gt;::<a class="el" href="class_b_s_t.html">BST</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_b_s_t.html">BST</a>&lt; KeyType, ValueType, KeyTypeLess &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>The <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> copy constructor. This constructor creates a <em>deep copy</em> of the of the original <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> passed in as argument. By deep copy we mean that new nodes are allocated, and all the key-value pairs are replicated on the new tree, preserving the same tree structure. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> we are copying-constructing from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_b_s_t.html#af21ef870def521a698f5ad9672badd1f" title="Creates a copy of a BST tree. ">clone( const BTNode *)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a99b5f3bb6438a7cdba827dc77d1d4ce5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType , typename KeyTypeLess &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_t.html">BST</a>&lt; KeyType, ValueType, KeyTypeLess &gt;::~<a class="el" href="class_b_s_t.html">BST</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Regular destructor. </p>
<p>The destructor frees all the memory allocated while creating the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a>. </p>

</div>
</div>
<a class="anchor" id="a8811bb87594111984e2ae68a88586af2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType , typename KeyTypeLess &gt; </div>
<div class="memtemplate">
template&lt;typename InputItr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_t.html">BST</a>&lt; KeyType, ValueType, KeyTypeLess &gt;::<a class="el" href="class_b_s_t.html">BST</a> </td>
          <td>(</td>
          <td class="paramtype">InputItr&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputItr&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyTypeLess &amp;&#160;</td>
          <td class="paramname"><em>comp</em> = <code>KeyTypeLess()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The range constructor. </p>
<p>The <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> range constructor. This constructor creates a new tree inserting key-value elements from the range <code>[first, last)</code> provided. We assume the range is valid and that each element of the range is of the type <a class="el" href="class_b_s_t.html#a0aa9307cbee74945dbbbf659c398d4a1" title="Represents a pair of key-value elements. ">BST::node_content_type</a>. If multiple elements in the range have keys that compare equivalent, only the first instance of the pair key-value is inserted.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputItr</td><td>The input iterator to the range we insert from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the begining of the range to copy from. </td></tr>
    <tr><td class="paramname">last</td><td>the end (exclusive) of the range to copy from. </td></tr>
    <tr><td class="paramname">comp</td><td>The function object necessary to compare keys. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab07b4e6d6818494bbc892df89ee4daad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType , typename KeyTypeLess &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_t.html">BST</a>&lt; KeyType, ValueType, KeyTypeLess &gt;::<a class="el" href="class_b_s_t.html">BST</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="class_b_s_t.html#a0aa9307cbee74945dbbbf659c398d4a1">node_content_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyTypeLess &amp;&#160;</td>
          <td class="paramname"><em>comp</em> = <code>KeyTypeLess()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The intializer list constructor. </p>
<p>The <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> initializer list constructor. This constructor creates a new tree inserting key-value elements from the range initializer list <code>init</code> provided. We assume the input list is valid and that each element of the list is of the type <a class="el" href="class_b_s_t.html#a0aa9307cbee74945dbbbf659c398d4a1" title="Represents a pair of key-value elements. ">BST::node_content_type</a>. If multiple elements in the initialize list have keys that compare equivalent, only the first instance of the pair key-value is inserted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>The initializer list to initialize the elements of the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> with. </td></tr>
    <tr><td class="paramname">comp</td><td>The function object necessary to compare keys. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a55ef77647f785480d292d2315550f734"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType , typename KeyTypeLess &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_t.html">BST</a>&lt; KeyType, ValueType, KeyTypeLess &gt;::clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_b_s_t_1_1_b_t_node.html">BTNode</a> *&amp;&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all the elements from the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a>. </p>
<p>Recursively deletes all the nodes of the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> pointed by <code>root</code>. All the allocated memory is freed to the system. The count of nodes is set to zero. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>A pointer to the tree we want to operate on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_b_s_t.html#a6ffadf800779b0f1b1a9742a3bc5cf66" title="Removes all the elements from the BST. ">clear(void)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6ffadf800779b0f1b1a9742a3bc5cf66"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType , typename KeyTypeLess  = std::less&lt;KeyType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_t.html">BST</a>&lt; KeyType, ValueType, KeyTypeLess &gt;::clear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all the elements from the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a>. </p>
<p>Removes all the nodes of the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a>, freeing the memory associated with the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a>. The count of nodes is set to zero. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_b_s_t.html#a55ef77647f785480d292d2315550f734" title="Removes all the elements from the BST. ">clear( BTNode * &amp; )</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af21ef870def521a698f5ad9672badd1f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType , typename KeyTypeLess &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_t.html">BST</a>&lt; KeyType, ValueType, KeyTypeLess &gt;::<a class="el" href="struct_b_s_t_1_1_b_t_node.html">BTNode</a> * <a class="el" href="class_b_s_t.html">BST</a>&lt; KeyType, ValueType, KeyTypeLess &gt;::clone </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_b_s_t_1_1_b_t_node.html">BTNode</a> *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a copy of a <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> tree. </p>
<p>Creates and returns an entire new tree that is a <em>deep copy</em> of the original <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> passed in as argument. By deep copy we mean that new nodes are allocated, and all the key-value pairs are replicated on the new tree, preserving the same tree structure. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>A pointer to the root of the tree we want to clone from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the cloned tree. </dd></dl>

</div>
</div>
<a class="anchor" id="a3c014718dd218e2ca758af266cc0b787"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType , typename KeyTypeLess &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_b_s_t.html">BST</a>&lt; KeyType, ValueType, KeyTypeLess &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_b_s_t_1_1_b_t_node.html">BTNode</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> contains a given key. </p>
<p>Recursively search the <code>root</code> for the key provided. Returns true if the key is found, or false otherwise. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>A pointer to the tree we want to operate on. </td></tr>
    <tr><td class="paramname">key</td><td>The key we are looking for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if key is found in the tree, false otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_b_s_t.html#a959aa07758e3ff26890e37db2a31b6b2" title="Checks whether the BST contains a given key. ">contains( const KeyType &amp; ) const</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a959aa07758e3ff26890e37db2a31b6b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType , typename KeyTypeLess &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_b_s_t.html">BST</a>&lt; KeyType, ValueType, KeyTypeLess &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> contains a given key. </p>
<p>Returns true if the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> contains a given key, or false otherwise. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key we are looking for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if key is found in the tree, false otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_b_s_t.html#a3c014718dd218e2ca758af266cc0b787" title="Checks whether the BST contains a given key. ">contains( const BTNode * , const KeyType &amp; ) const</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a582ec5f3bc333f1e9c1deed3526e6a55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType , typename KeyTypeLess  = std::less&lt;KeyType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_b_s_t.html">BST</a>&lt; KeyType, ValueType, KeyTypeLess &gt;::empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> is empty, or false otherwise. </p>

</div>
</div>
<a class="anchor" id="a1610824df7207dd077fec30b82174a9e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType , typename KeyTypeLess &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const ValueType &amp; <a class="el" href="class_b_s_t.html">BST</a>&lt; KeyType, ValueType, KeyTypeLess &gt;::find_max </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value associated with the largest key. </p>

</div>
</div>
<a class="anchor" id="a262042430a5671f2964ec55fd0db5887"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType , typename KeyTypeLess &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const ValueType &amp; <a class="el" href="class_b_s_t.html">BST</a>&lt; KeyType, ValueType, KeyTypeLess &gt;::find_min </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value associated with the smallest key. </p>

</div>
</div>
<a class="anchor" id="a2da99953436debe2868f93bd18398b11"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType , typename KeyTypeLess &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_b_s_t.html">BST</a>&lt; KeyType, ValueType, KeyTypeLess &gt;::<a class="el" href="struct_b_s_t_1_1_b_t_node.html">BTNode</a> * <a class="el" href="class_b_s_t.html">BST</a>&lt; KeyType, ValueType, KeyTypeLess &gt;::get_smallest_leaf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_b_s_t_1_1_b_t_node.html">BTNode</a> *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> node with the smallest key value. </p>
<p>Helper method needed by <a class="el" href="class_b_s_t.html#ab3369784d746d15731edf741729f15ad" title="Removes from the BST a node containing the requested key. ">remove()</a> when the target node has 2 children. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Pointer to the root node of a tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a leaf with the smallest key (left most leaf). </dd></dl>

</div>
</div>
<a class="anchor" id="abbfbc935cb31754a1715cca4490994f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType , typename KeyTypeLess &gt; </div>
<div class="memtemplate">
template&lt;typename UnaryFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_t.html">BST</a>&lt; KeyType, ValueType, KeyTypeLess &gt;::inorder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_b_s_t_1_1_b_t_node.html">BTNode</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnaryFunction &amp;&#160;</td>
          <td class="paramname"><em>visit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Traverses and visits each <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> node in <b>inorder</b> fashion. </p>
<p>Recursively traverses the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> in <b>inorder</b> while applying an unary function to the value field of each node. This strategy is knows as <a href="https://en.wikipedia.org/wiki/Visitor_pattern"><b>the visitor design pattern</b></a>, which enables the client code freedom to specify what to do to each data node, according to application needs. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UnaryFunction</td><td>A function object of the form <code>std::function&lt;void( const ValueType  &amp; )&gt;</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>A pointer to the root of the tree we want to traverse. </td></tr>
    <tr><td class="paramname">visit</td><td>The function object to be applied to each value stored in the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_b_s_t.html#a46608ca07862f7f13cf3520ec6ade82d" title="Traverses and visits each BST node in inorder fashion. ">inorder( const UnaryFunction &amp; ) const</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a46608ca07862f7f13cf3520ec6ade82d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType , typename KeyTypeLess &gt; </div>
<div class="memtemplate">
template&lt;typename UnaryFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_t.html">BST</a>&lt; KeyType, ValueType, KeyTypeLess &gt;::inorder </td>
          <td>(</td>
          <td class="paramtype">const UnaryFunction &amp;&#160;</td>
          <td class="paramname"><em>visit</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverses and visits each <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> node in <b>inorder</b> fashion. </p>
<p>During the <b>inorder</b> <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> traversal the method applies an unary function to the value field of each visited node. This strategy is knows as <a href="https://en.wikipedia.org/wiki/Visitor_pattern"><b>the visitor design pattern</b></a>, which enables the client code freedom to specify what to do to each data node, according to application needs. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UnaryFunction</td><td>A function object of the form <code>std::function&lt;void( const ValueType  &amp; )&gt;</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visit</td><td>The function object to be applied to each value stored in the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_b_s_t.html#abbfbc935cb31754a1715cca4490994f8" title="Traverses and visits each BST node in inorder fashion. ">inorder( const BTNode * , const UnaryFunction &amp; ) const</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2caab48e5c6f1400f7b9ae2e11fb1680"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType , typename KeyTypeLess &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_t.html">BST</a>&lt; KeyType, ValueType, KeyTypeLess &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_b_s_t_1_1_b_t_node.html">BTNode</a> *&amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new pair &lt;<code>key</code>,<code>value</code>&gt; in the tree. </p>
<p>Recursively tried to look for the right place to createa and insert a new node with a &lt;<code>key</code>,<code>value</code>&gt; pair in the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> tree if the key is not already stored in the tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>A pointer to the tree we want to operate on. </td></tr>
    <tr><td class="paramname">key</td><td>The key associated with the value we wish to operate on. </td></tr>
    <tr><td class="paramname">value</td><td>The value we wish to store in the tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_b_s_t.html#a809a130ceaa2dbb3a2b077f321675593" title="Inserts a new pair &lt;key,value&gt; in the tree. ">insert(const KeyType &amp;, const ValueType &amp; )</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a809a130ceaa2dbb3a2b077f321675593"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType , typename KeyTypeLess &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_t.html">BST</a>&lt; KeyType, ValueType, KeyTypeLess &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new pair &lt;<code>key</code>,<code>value</code>&gt; in the tree. </p>
<p>Creates and inserts a new node with a &lt;<code>key</code>,<code>value</code>&gt; pair in the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> tree if the key is not already stored in the tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key associated with the value we wish to operate on. </td></tr>
    <tr><td class="paramname">value</td><td>The value we wish to store in the tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_b_s_t.html#a2caab48e5c6f1400f7b9ae2e11fb1680" title="Inserts a new pair &lt;key,value&gt; in the tree. ">insert( BTNode * &amp; , const KeyType &amp; , const ValueType &amp; )</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a777c36ccd3b24f144e0603f20f5eac9d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType , typename KeyTypeLess &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_t.html">BST</a>&lt; KeyType, ValueType, KeyTypeLess &gt; &amp; <a class="el" href="class_b_s_t.html">BST</a>&lt; KeyType, ValueType, KeyTypeLess &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_b_s_t.html">BST</a>&lt; KeyType, ValueType, KeyTypeLess &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The copy assignment operator. </p>
<p>The <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> copy assignment operator. This operator replaces the current <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> content with a <em>deep copy</em> of the elements from the <code>rhs</code> <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a>. By deep copy we mean that new nodes are allocated, and all the key-value pairs are replicated on the new tree, preserving the same tree structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> container to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code> to enable chained assignments. </dd></dl>

</div>
</div>
<a class="anchor" id="abcafcb893066444795e8145684011457"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType , typename KeyTypeLess &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_t.html">BST</a>&lt; KeyType, ValueType, KeyTypeLess &gt; &amp; <a class="el" href="class_b_s_t.html">BST</a>&lt; KeyType, ValueType, KeyTypeLess &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="class_b_s_t.html#a0aa9307cbee74945dbbbf659c398d4a1">node_content_type</a> &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The initializer list assignment operator. </p>
<p>The <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> initializer list assignment operator. This operator replaces the current <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> content with the contents from the intializer list <code>ilist</code>. We assume the input list is valid and that each element of the list is of the type <a class="el" href="class_b_s_t.html#a0aa9307cbee74945dbbbf659c398d4a1" title="Represents a pair of key-value elements. ">BST::node_content_type</a>. If multiple elements in the initialize list have keys that compare equivalent, only the first instance of the pair key-value is inserted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>The initialize list to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code> to enable chained assignments. </dd></dl>

</div>
</div>
<a class="anchor" id="a11b5bd16742a542b361eebe5f2baa310"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType , typename KeyTypeLess &gt; </div>
<div class="memtemplate">
template&lt;typename UnaryFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_t.html">BST</a>&lt; KeyType, ValueType, KeyTypeLess &gt;::postorder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_b_s_t_1_1_b_t_node.html">BTNode</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnaryFunction &amp;&#160;</td>
          <td class="paramname"><em>visit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Traverses and visits each <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> node in <b>postorder</b> fashion. </p>
<p>Recursively traverses the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> in <b>postorder</b> while applying an unary function to the value field of each node. This strategy is knows as <a href="https://en.wikipedia.org/wiki/Visitor_pattern"><b>the visitor design pattern</b></a>, which enables the client code freedom to specify what to do to each data node, according to application needs. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UnaryFunction</td><td>A function object of the form <code>std::function&lt;void( const ValueType  &amp; )&gt;</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>A pointer to the root of the tree we want to traverse. </td></tr>
    <tr><td class="paramname">visit</td><td>The function object to be applied to each value stored in the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_b_s_t.html#a938be48246fd9b0b81e64d111f2e1a5d" title="Traverses and visits each BST node in postorder fashion. ">postorder( const UnaryFunction &amp; ) const</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a938be48246fd9b0b81e64d111f2e1a5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType , typename KeyTypeLess &gt; </div>
<div class="memtemplate">
template&lt;typename UnaryFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_t.html">BST</a>&lt; KeyType, ValueType, KeyTypeLess &gt;::postorder </td>
          <td>(</td>
          <td class="paramtype">const UnaryFunction &amp;&#160;</td>
          <td class="paramname"><em>visit</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverses and visits each <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> node in <b>postorder</b> fashion. </p>
<p>During the <b>postorder</b> <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> traversal the method applies an unary function to the value field of each visited node. This strategy is knows as <a href="https://en.wikipedia.org/wiki/Visitor_pattern"><b>the visitor design pattern</b></a>, which enables the client code freedom to specify what to do to each data node, according to application needs. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UnaryFunction</td><td>A function object of the form <code>std::function&lt;void( const ValueType  &amp; )&gt;</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visit</td><td>The function object to be applied to each value stored in the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_b_s_t.html#a11b5bd16742a542b361eebe5f2baa310" title="Traverses and visits each BST node in postorder fashion. ">postorder( const BTNode * , const UnaryFunction &amp; ) const</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a10b4da6797656b7155f92fa7e2be3f1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType , typename KeyTypeLess &gt; </div>
<div class="memtemplate">
template&lt;typename UnaryFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_t.html">BST</a>&lt; KeyType, ValueType, KeyTypeLess &gt;::preorder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_b_s_t_1_1_b_t_node.html">BTNode</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnaryFunction &amp;&#160;</td>
          <td class="paramname"><em>visit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Traverses and visits each <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> node in <b>preorder</b> fashion. </p>
<p>Recursively traverses the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> in <b>preorder</b> while applying an unary function to the value field of each node. This strategy is knows as <a href="https://en.wikipedia.org/wiki/Visitor_pattern"><b>the visitor design pattern</b></a>, which enables the client code freedom to specify what to do to each data node, according to application needs. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UnaryFunction</td><td>A function object of the form <code>std::function&lt;void( const ValueType  &amp; )&gt;</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>A pointer to the root of the tree we want to traverse. </td></tr>
    <tr><td class="paramname">visit</td><td>The function object to be applied to each value stored in the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_b_s_t.html#afafd8425898de634afe1d229420cfbb8" title="Traverses and visits each BST node in preorder fashion. ">preorder( const UnaryFunction &amp; ) const</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afafd8425898de634afe1d229420cfbb8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType , typename KeyTypeLess &gt; </div>
<div class="memtemplate">
template&lt;typename UnaryFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_t.html">BST</a>&lt; KeyType, ValueType, KeyTypeLess &gt;::preorder </td>
          <td>(</td>
          <td class="paramtype">const UnaryFunction &amp;&#160;</td>
          <td class="paramname"><em>visit</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverses and visits each <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> node in <b>preorder</b> fashion. </p>
<p>During the <b>preorder</b> <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> traversal the method applies an unary function to the value field of each visited node. This strategy is knows as <a href="https://en.wikipedia.org/wiki/Visitor_pattern"><b>the visitor design pattern</b></a>, which enables the client code to decouple the algorithm to be applied to each node from the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> structure. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UnaryFunction</td><td>A function object of the form <code>std::function&lt;void( const ValueType  &amp; )&gt;</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visit</td><td>The function object to be applied to each value stored in the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_b_s_t.html#a10b4da6797656b7155f92fa7e2be3f1d" title="Traverses and visits each BST node in preorder fashion. ">preorder( const BTNode * , const UnaryFunction &amp; ) const</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab3369784d746d15731edf741729f15ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType , typename KeyTypeLess &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_t.html">BST</a>&lt; KeyType, ValueType, KeyTypeLess &gt;::remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_b_s_t_1_1_b_t_node.html">BTNode</a> *&amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes from the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> a node containing the requested key. </p>
<p>Recursuvely tries to look for and remove from the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> a node containing the requested key, if one is found in the tree. The deletion might modifiy the tree structure to preserve the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> properties. If the key is not found, nothing happens to the tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>A pointer to the tree we want to operate on. </td></tr>
    <tr><td class="paramname">key</td><td>The key associated with the value we wish to operate on. </td></tr>
    <tr><td class="paramname">value</td><td>The value we wish to store in the tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa9f0f207322311366b9b014755a798ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType , typename KeyTypeLess &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_t.html">BST</a>&lt; KeyType, ValueType, KeyTypeLess &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>k_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes from the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> a node containing the requested key. </p>
<p>Removes from the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> a node containing the requested key if one is found in the tree. The deletion might modifiy the tree structure to preserve the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> properties. If the key is not found, nothing happens to the tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key associated with the value we wish to operate on. </td></tr>
    <tr><td class="paramname">value</td><td>The value we wish to store in the tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>remove( BTNode * &amp; , const KeyType &amp; , const ValueType &amp; ) </dd></dl>

</div>
</div>
<a class="anchor" id="ad4e63b5360a5252606dece4c5972c36d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType , typename KeyTypeLess &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_b_s_t.html">BST</a>&lt; KeyType, ValueType, KeyTypeLess &gt;::retrieve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_b_s_t_1_1_b_t_node.html">BTNode</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves in <code>value</code> the value associated with the provided key. </p>
<p>Recursively tries to retrieve from the <code>root</code> <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> the value associated with the provided key, if one is found. The retrieved value is stored in the output reference parameter <code>value</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>A pointer to the tree we want to operate on. </td></tr>
    <tr><td class="paramname">key</td><td>The key we are looking for. </td></tr>
    <tr><td class="paramname">value</td><td>The value associated with the target key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if key is found in the tree and the data is retrieved in value, false otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_b_s_t.html#ad969e54369b6edee09f68b2b79a22f08" title="Retrieves in value the value associated with the provided key. ">retrieve( const KeyType &amp; , ValueType &amp; ) const</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad969e54369b6edee09f68b2b79a22f08"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType , typename KeyTypeLess &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_b_s_t.html">BST</a>&lt; KeyType, ValueType, KeyTypeLess &gt;::retrieve </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves in <code>value</code> the value associated with the provided key. </p>
<p>Retrieves from the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> the value associated with the provided key, if one is found. The retrieved value is stored in the output reference parameter <code>value</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key we are looking for. </td></tr>
    <tr><td class="paramname">value</td><td>The value associated with the target key we copied into. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if key is found in the tree and the data is retrieved in value, false otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_b_s_t.html#ad4e63b5360a5252606dece4c5972c36d" title="Retrieves in value the value associated with the provided key. ">retrieve( const BTNode * , const KeyType &amp; , ValueType &amp; ) const</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a95dafd989628a5cf95f8e82151bbb432"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType , typename KeyTypeLess  = std::less&lt;KeyType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="class_b_s_t.html">BST</a>&lt; KeyType, ValueType, KeyTypeLess &gt;::size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of key-value elements stored in the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a>. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="aaf95a8d45e30cd664017a788b0c5193b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType , typename KeyTypeLess  = std::less&lt;KeyType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_b_s_t.html">BST</a>&lt; KeyType, ValueType, KeyTypeLess &gt; &amp;&#160;</td>
          <td class="paramname"><em>root_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints out an ascii tree-bar representation of the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a>. </p>
<p>Sends to the output stream an ascii tree-bar representation of the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a>. Left subtrees appear before right subtrees. Null nodes are represented with <code>X</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os_</td><td>The output stream to write to. </td></tr>
    <tr><td class="paramname">root_</td><td>The pointer to the root of the <a class="el" href="class_b_s_t.html" title="This class implements a generic Binary Search Tree. ">BST</a> we wish to visualize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the ostream object to enable further chained operation on the ostream object. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a7a6d8e3ed3109602f468ef20d03f733c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType , typename KeyTypeLess  = std::less&lt;KeyType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KeyTypeLess <a class="el" href="class_b_s_t.html">BST</a>&lt; KeyType, ValueType, KeyTypeLess &gt;::m_key_less</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The key comparator function object. </p>

</div>
</div>
<a class="anchor" id="a38f358a38c855ebc8bd866f6ae96aa5a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType , typename KeyTypeLess  = std::less&lt;KeyType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="class_b_s_t.html">BST</a>&lt; KeyType, ValueType, KeyTypeLess &gt;::m_n_nodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The count of nodes stored in the tree. </p>

</div>
</div>
<a class="anchor" id="af2a361060692deacc5be429288eece96"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType , typename KeyTypeLess  = std::less&lt;KeyType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_b_s_t_1_1_b_t_node.html">BTNode</a>* <a class="el" href="class_b_s_t.html">BST</a>&lt; KeyType, ValueType, KeyTypeLess &gt;::m_root</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to the root of the entire tree. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="bst_8h_source.html">bst.h</a></li>
<li>include/<a class="el" href="bst_8inl.html">bst.inl</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
